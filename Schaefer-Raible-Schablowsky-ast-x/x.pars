/* Project:  Compiler for language x
 * Descr:    LR parser for language x
 * Kind:     Parser specification
 */

SCANNER x_scan

PARSER  x_pars

GLOBAL {
	#include <stdio.h>
	#include "rString.h"
	#include "Tree.h"
	
	static tTree setNextVarDec(tTree varDec, tTree next) {
		varDec->var_dec.Next = next;
		return varDec;
	}
	
	static tTree setNextSTMT(tTree stmt, tTree next) {
		stmt->STMT.Next = next;
		return stmt;
	}
}

PREC LEFT '||'
     LEFT '&&'
     LEFT '+' '-'
     LEFT '*' '/'
     NONE UNARY '~'


RULE

root = p:program 
	 {=> {TreeRoot = p:tree;};} .

program = m:metainfo v:vardeclarationblock e:executionblock
		{tree := mPROGRAM(mname(m:name), v:tree, e:tree);} .

metainfo = PROG i:identifier '.' 
		 {name := i:Ident;} .

/* variable declarations */
vardeclarationblock = VAR v:vardeclarationlist END_VAR
					{tree := v:tree;} .

vardeclarationlist = <
	= h:vardeclaration t:vardeclarationlist 
	{tree := setNextVarDec(h:tree, t:tree);}.
	= // epsilon
	{tree := mno_var_dec();} . 
> .

vardeclaration = v:varinout t:vartype i:identifier '.'
			   {tree := mvar_dec(NoTree, v:tree, t:tree, mname(i:Ident));} .

varinout = <
	= // epsilon
	{tree := mVARINOUT(0, 0);} . 
	= '?'
	{tree := mVARINOUT(1, 0);} .
	= '!'
	{tree := mVARINOUT(0, 1);} .
	= '?!'
	{tree := mVARINOUT(1, 1);} .
> .

vartype = <
	= int
	{tree := mint_type();} .
	= string
	{tree := mstring_type();} .
	= float
	{tree := mfloat_type();} .
> .

/* executionblock */
executionblock = EXEC s:statementlist END_EXEC 
			   {tree := s:tree;} .

statementlist = <
	= h:statement t:statementlist
	{tree := setNextSTMT(h:tree, t:tree);} .
	= // epsilon
	{tree := mno_stmt();} .
> .

statement = <
	= s:statementblock 
	{tree := s:tree;}.
	= i:identifier a:assignop e:expr '.'
	{tree := massign_stmt(NoTree, a:op, mname(i:Ident), e:tree);} .
	= i:ifthenelse_stmt
	{tree := i:tree;} .
	= f:for_stmt
	{tree := f:tree;} .
	= w:while_stmt
	{tree := w:tree;} .
> .

statementblock = begin s:statementlist end
			   {tree := s:tree;} .

assignop = <
	= '=' 
	{op := '=';} .
	= '+='
	{op := '+';} .
	= '-='
	{op := '-';} .
	= '*='
	{op := '*';} .
	= '/='
	{op := '/';} .
> .

ifthenelse_stmt = if c:condition then t:statementlist e:else_o endif
				{tree := mif_stmt(NoTree, c:tree, t:tree, e:tree);} .

else_o = <
	= else s:statementlist
	{tree := s:tree;} .
	= elif c:condition then t:statementlist e:else_o
	{tree := mif_stmt(NoTree, c:tree, t:tree, e:tree);} .
	= // epsilon
	{tree := mno_stmt();} .
> .

for_stmt = for i1:identifier '=' e1:expr '.' c:condition '.' i2:identifier o:assignop e2:expr do s:statementlist endfor 
		 {tree := mfor_stmt(NoTree, massign_stmt(mno_stmt(), '=', mname(i1:Ident), e1:tree), c:tree, massign_stmt(mno_stmt(), o:op, mname(i2:Ident), e2:tree), s:tree);} .

while_stmt = while c:condition do s:statementlist endwhile
		   {tree := mwhile_stmt(NoTree, c:tree, s:tree);} .

expr = <
	= i:int_const 
	{tree := mint_const(i:Value);} .
	= f:float_const
	{tree := mfloat_const(f:Value);} .
	= s:string_const
	{tree := mstring_const(s:Value);} .
	= i:identifier
	{tree := mname(i:Ident);} .
	= l:expr '+' r:expr
	{tree := mbinary_expr('+', l:tree, r:tree);} .
	= l:expr '-' r:expr
	{tree := mbinary_expr('-', l:tree, r:tree);} .
	= l:expr '*' r:expr
	{tree := mbinary_expr('*', l:tree, r:tree);} .
	= l:expr '/' r:expr
	{tree := mbinary_expr('/', l:tree, r:tree);} .
	= '-' e:expr PREC UNARY
	{tree := munary_expr('-', e:tree);} .
	= '(' e:expr ')'
	{tree := e:tree;} .
> .

condition = <
	= l:expr '==' r:expr
	{tree := mbin_expr_cond(eq, l:tree, r:tree);} .
	= l:expr '~=' r:expr
	{tree := mbin_expr_cond(neq, l:tree, r:tree);} .
	= l:expr '<' r:expr
	{tree := mbin_expr_cond(lt, l:tree, r:tree);} .
	= l:expr '>' r:expr
	{tree := mbin_expr_cond(gt, l:tree, r:tree);} .
	= l:expr '<=' r:expr
	{tree := mbin_expr_cond(let, l:tree, r:tree);} .
	= l:expr '>=' r:expr
	{tree := mbin_expr_cond(get, l:tree, r:tree);} .
	= l:condition '&&' r:condition
	{tree := mbin_cond('&', l:tree, r:tree);} .
	= l:condition '||' r:condition
	{tree := mbin_cond('|', l:tree, r:tree);} .
	= '~' c:condition
	{tree := munary_cond('~', c:tree);} .
	= '(' c:condition ')'
	{tree := c:tree;} .
> .

/* Tokens */
int_const:    [Value: long]       {Value := 0;        } .
float_const:  [Value: double]     {Value := 0.0;      } .
string_const: [Value: tStringRef] {Value := NoString; } .
identifier:   [Ident: tIdent] 	  {Ident := NoIdent;  } .

/* Attributes */
MODULE attributes
PROPERTY SYN
DECLARE
 program
 vardeclarationblock
 vardeclarationlist
 vardeclaration
 varinout
 vartype
 executionblock
 statementlist
 statement
 statementblock
 ifthenelse_stmt
 else_o
 for_stmt
 while_stmt
 expr
 condition = [tree: tTree].
 
 metainfo = [name: tIdent].
 
 assignop = [op: char].
END attributes
